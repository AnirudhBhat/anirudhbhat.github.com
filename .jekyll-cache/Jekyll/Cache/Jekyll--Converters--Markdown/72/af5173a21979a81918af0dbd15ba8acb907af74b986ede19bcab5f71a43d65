I"®<p>async and await are not keywords in Kotlin and are not even part of its standard library.</p>

<p>kotlinx.coroutines is a rich library for coroutines developed by JetBrains. It contains a number of high-level coroutine-enabled primitives that this guide covers, including launch, async and others.</p>

<p>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on the kotlinx-coroutines-core module</p>

<p>A coroutine is an instance of suspendable computation. coroutine is not bound to any particular thread. It may suspend its execution in one thread and resume in another one.</p>

<p><strong>RunBlocking</strong></p>

<p>The name of runBlocking means that the thread that runs it (in this case â€” the main thread) gets blocked for the duration of the call, until all the coroutines inside runBlocking { â€¦ } complete their execution.</p>

<p><strong>Structured Concurrency</strong></p>

<p>Coroutines follow a principle of structured concurrency which means that new coroutines can be only launched in a specific CoroutineScope which delimits the lifetime of the coroutine. In a real application, you will be launching a lot of coroutines. Structured concurrency ensures that they are not lost and do not leak. An outer scope cannot complete until all its children coroutines complete. Structured concurrency also ensures that any errors in the code are properly reported and are never lost.</p>

<p><strong>Scope Builder</strong></p>

<p>runBlocking and coroutineScope builders may look similar because they both wait for their body and all its children to complete. The main difference is that the runBlocking method blocks the current thread for waiting, while coroutineScope just suspends, releasing the underlying thread for other usages. Because of that difference, runBlocking is a regular function and coroutineScope is a suspending function.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// Sequentially executes doWorld followed by "Done"</span>
<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="nf">runBlocking</span> <span class="p">{</span>
    <span class="nf">doWorld</span><span class="p">()</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"Done"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Concurrently executes both sections</span>
<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">doWorld</span><span class="p">()</span> <span class="p">=</span> <span class="nf">coroutineScope</span> <span class="p">{</span> <span class="c1">// this: CoroutineScope</span>
    <span class="nf">launch</span> <span class="p">{</span>
        <span class="nf">delay</span><span class="p">(</span><span class="mi">2000L</span><span class="p">)</span>
        <span class="nf">println</span><span class="p">(</span><span class="s">"World 2"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">launch</span> <span class="p">{</span>
        <span class="nf">delay</span><span class="p">(</span><span class="mi">1000L</span><span class="p">)</span>
        <span class="nf">println</span><span class="p">(</span><span class="s">"World 1"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div></div>

<p>A coroutineScope in doWorld completes only after both are complete, so doWorld returns and allows Done string to be printed only after that.</p>

<p><strong>Making coroutine wait through the Job</strong></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">job</span> <span class="p">=</span> <span class="nf">launch</span> <span class="p">{</span> <span class="c1">// launch a new coroutine and keep a reference to its Job</span>
    <span class="nf">delay</span><span class="p">(</span><span class="mi">1000L</span><span class="p">)</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"World!"</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">println</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
<span class="n">job</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span> <span class="c1">// wait until child coroutine completes</span>
<span class="nf">println</span><span class="p">(</span><span class="s">"Done"</span><span class="p">)</span> 

</code></pre></div></div>
:ET